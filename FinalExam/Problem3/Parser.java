package Test2.Problem4;

public class Parser {
	
	void expr() {
		 System.out.println("Enter <expr>\n");
		/* Parse the first term */
		 term();
		/* As long as the next token is + or -, get
		 the next token and parse the next term */
		 while (nextToken == ADD_OP || nextToken == SUB_OP) {
			 lex();
			 term();
		 }
		 System.out.println("Exit <expr>\n");
	}

	/* term
	 Parses strings in the language generated by the rule:
	 <term> -> <factor> {(* | /) <factor>}
	 */
	void term() {
		 System.out.println("Enter <term>\n");
		/* Parse the first factor */
		 factor();
		/* As long as the next token is * or /, get the
		 next token and parse the next factor */
		 while (nextToken == MULT_OP || nextToken == DIV_OP) {
			 lex();
			 factor();
		 }
		 System.out.println("Exit <term>\n");
	}

	/* factor
	 Parses strings in the language generated by the rule:
	 <factor> -> id | int_constant | ( <expr> )
	 */
	void factor() {
		 System.out.println("Enter <factor>\n");
		/* Determine which RHS */
		 if (nextToken == IDENT || nextToken == INT_LIT)
			/* Get the next token */
			 lex();
			/* If the RHS is ( <expr> ), call lex to pass over the
			 left parenthesis, call expr, and check for the right
			 parenthesis */
		 else { if (nextToken == LEFT_PAREN) {
			 lex();
			 expr();
			 if (nextToken == RIGHT_PAREN)
			 	lex();
			 else
			 	error();
			 }
			/* It was not an id, an integer literal, or a left
			 parenthesis */
			 else
			 error();
		 }
		 System.out.println("Exit <factor>\n");
	}

}
